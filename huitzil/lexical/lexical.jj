/* Lexical Huitzil */

PARSER_BEGIN(Lexical)

//package for all files in the lexical/ directory
package lexical;
//public class
public class Lexical { }

PARSER_END(Lexical)

//TOKENS
SKIP:
{
	" "
	|"\t"
	|"\n"
	|"\r"

}
SKIP:
{
  //TOKEN's name: t_comment_multiline
  <t_comment_multiline: "#>"(~[])*"<#"> : DEFAULT
  //TOKEN's name: t_comment
  |<t_comment: "#"(~["\r", "\n"])* > : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_conditional
	<t_conditional: "if"|"unless">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_elif
	<t_elif: "elif">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_parenthesis_group_open
	<t_parenthesis_group_open: "(">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_parenthesis_group_close
	<t_parenthesis_group_close: ")">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_colons
	<t_colons: ":">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_else
	<t_else: "else">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_bool
	<t_bool: "true"|"false">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_assignment
	<t_assignment: "=">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_comparison_operator
	<t_comparison_operator: "=="|"eq"|"==="|"id"|"<"|"lt"|"<="|"le"|">"|"gt"|">="|"ge"|"!="|"ne"|"!=="|"ni">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_logic_operator
	<t_logic_operator: "&&"|"and"|"||"|"or"|"!"|"not">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_switch
	<t_switch: "switch">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_case
	<t_case: "case">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_default
	<t_default: "default">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_break
	<t_break: "break">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_next
	<t_next: "next">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_not_yet
	<t_not_yet: "not_yet">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_again
	<t_again: "again">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_loop
	<t_for : "for"> : DEFAULT
	| <t_while : "while"> : DEFAULT
	| <t_until : "until"> : DEFAULT
	
}
TOKEN:
{
	//TOKEN's name: t_do
	<t_do: "do">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_range
	<t_range: ".."|"range">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_comma
	<t_comma: ",">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_output
	<t_output: "output">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_text
	<t_text: "'"|"\"">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_input
	<t_input: "input">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_aritmethic_operator
	<t_aritmethic_operator: "+"|"-"|"/"|"//"|"*"|"**"|"%">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_aritmethic_operator_assignment
	<t_aritmethic_operator_assignment: "+="|"-="|"*="|"/="|"//="|"**=="|"%=">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_bitwise_operator
	<t_bitwise_operator: "&"|"|"|"^"|"~"|"<<"|">>">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_bitwise_operator_assignment
	<t_bitwise_operator_assignment: "&="|"|="|"^="|"~="|"<<="|">>=">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_type_operator
	<t_type_operator: "type_of"|"instance_of"|"convert">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_data_type
	<t_data_type: "boolean"|"string"|"int"|"float"|"snot"|"complex"|"list"|"tuple"|"queue"|"stack"|"set"|"dictionary"|"char"|"datetime"|"timestamp"|"file"|"random">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_membership_operator
	<t_membership_operator: "in"|"not_in">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_identity_operator
	<t_identity_operator: "is"|"not_is">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_array_open
	<t_array_open: "[">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_array_close
	<t_array_close: "]">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_set_open
	<t_set_open: "{">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_set_close
	<t_set_close: "}">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_try
	<t_try: "try">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_catch
	<t_catch: "catch">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_finally
	<t_finally: "finally">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_throw
	<t_throw: "throw">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_null
	<t_null: "null">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_undefined
	<t_undefined: "undefined">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_method
	<t_method: "method">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_lambda
	<t_lambda: "=>"|"lambda">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_return
	<t_return: "return">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_data_security
	<t_data_security: "public"|"private"|"protected"|"internal">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_class
	<t_class: "class">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_class_construct
	<t_class_construct: "construct">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_class_destruct
	<t_class_destruct: "destruct">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_attribute
	<t_attribute: "attribute">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_my
	<t_my: "my">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_import
	<t_import: "import">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_strict
	<t_strict: "strict">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_var
	<t_var: "var">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_escape_character
	<t_escape_character: "\\"|"\\b"|"\\f"|"\\n"|"\\r"|"\\t"|"\\v"|"\\'"|"\\\""|"\\\\">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_string_method
	<t_string_method: "split"|"replace"|"flip"|"lower"|"upper"|"trim"|"lenght"|"capitalize"|"index"|"concatenate">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_dot
	<t_dot: ".">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_dot_assignment
	<t_dot_assignment: ".=">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_number_method
	<t_number_method: "absolute"|"ceil"|"compare"|"exponential"|"f_absolute"|"floor"|"log"|"log10"|"max"|"min"|"modf"|"pow"|"round"|"sqrt"|"random_range"|"choice"|"random_generate">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_trigonometric_method
	<t_trigonometric_method: "acos"|"asin"|"atan"|"cos"|"sin"|"tan"|"degrees"|"radians">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_array_method
	<t_array_method: "insert"|"insert_at"|"remove"|"remove_at"|"extend"|"clear"|"copy"|"count"|"reverse"|"sort"|"shuffle"|"peek"|"pop"|"push"|"enqueue"|"dequeue">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_set_method
	<t_set_method: "add"|"discard"|"get"|"difference"|"difference_symmetric"|"intersection"|"union"|"cartesian_product"|"complement">{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_var_name
	<t_var_name: (["a"-"z","A"-"Z"]|"_")(["a"-"z","A"-"Z"]|"_"|["0"-"9"])*>{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_char_value
	<t_char_value: ("\""(~["\n"])"\"")|("'"(~["\n"])"'")>{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_string_value
	<t_string_value: ("\""(~["\n"])*"\"")|("'"(~["\n"])*"'")>{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_int_value
	<t_int_value: ("-"|"+")?(["0"-"9"])+>{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_float_value
	<t_float_value: <t_int_value>"."(["0"-"9"])+>{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_snot_value
	<t_snot_value: <t_int_value>("."(["0"-"9"])+)?(("e"|"E")("-"|"+")?(["0"-"9"])+)?>{  } : DEFAULT
}
TOKEN:
{
	//TOKEN's name: t_complex_value
	<t_complex_value: (<t_int_value>("."(["0"-"9"])+)?)(<t_int_value>("."(["0"-"9"])+)?)"i">{  } : DEFAULT
}

void g_program():
{ }
{
        (g_strict())? (g_import())? g_body()
        {
                // TODO: implement AST
        }
}

void g_body():
{ }
{
        (g_instruction() | g_method()) g_more_body()
        {
                // TODO: implement AST
        }
}

void g_more_body():
{ }
{
        (g_body())?
        {
                // TODO: implement AST
        }
}

void g_instruction():
{ }
{
        (g_declaration() | g_conditional() | g_while() | g_for() | g_try() | g_output() | g_switch())
        {
                // TODO: implement AST
        }
}

void g_declaration():
{ }
{
        <t_var> <t_var_name> <t_assignment> (g_declaration_single() | g_declaration_complete())
        {
                // TODO: implement AST
        }
}

void g_declaration_single():
{ }
{
        (g_value() | <t_null> | g_input()) g_more_vars()
        {
                // TODO: implement AST
        }
}

void g_declaration_complete():
{ }
{
        <t_data_type> <t_parenthesis_group_open> (g_value() | <t_null> | g_input()) <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}


void g_value():
{ }
{
        g_text_value() | g_number_value() | <t_var_name> | <t_bool>
        {
                // TODO: implement AST
        }
}

void g_text_value():
{ }
{
        <t_string_value> | <t_char_value>
        {
                // TODO: implement AST
        }
}

void g_number_value():
{ }
{
        <t_int_value> | <t_float_value> | <t_complex_value> | <t_snot_value>
        {
                // TODO: implement AST
        }
}

void g_more_vars():
{ }
{
        (<t_comma> <t_var_name> <t_assignment> (g_declaration_single() | g_declaration_complete()))?
        {
                // TODO: implement AST
        }
}

void g_import():
{ }
{
        <t_import> <t_string_value> g_more_imports()
        {
                // TODO: implement AST
        }
}

void g_more_imports():
{ }
{
        (<t_comma> <t_string_value>)?
        {
                // TODO: implement AST
        }
}

void g_strict():
{ }
{
        <t_strict>
        {
                // TODO: implement AST
        }
}

void g_conditional():
{ }
{
        <t_conditional> <t_parenthesis_group_open> g_condition() <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> (g_elif())? (g_else())? (g_finally())?
        {
                // TODO: implement AST
        }
}

void g_condition():
{ }
{
        g_logic_expression() | g_comparison()
        {
                // TODO: implement AST
        }
}

void g_comparison():
{ }
{
        g_value() <t_comparison_operator> g_value()
        {
                // TODO: implement AST
        }
}

void g_logic_expression():
{ }
{
        <t_parenthesis_group_open> g_comparison() <t_parenthesis_group_close> <t_logic_operator> <t_parenthesis_group_open> g_comparison() <t_parenthesis_group_close> g_more_logic_expressions()
        {
                // TODO: implement AST
        }
}

void g_more_logic_expressions():
{ }
{
        (g_logic_expression())?
        {
                // TODO: implement AST
        }
}

void g_else():
{ }
{
        <t_else> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_elif():
{ }
{
        <t_elif> <t_parenthesis_group_open> g_condition() <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> g_more_elifs()
        {
                // TODO: implement AST
        }
}

void g_more_elifs():
{ }
{
        (g_elif())?
        {
                // TODO: implement AST
        }
}

void g_while():
{ }
{
        <t_while> <t_parenthesis_group_open> g_condition() <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> (g_finally())?
        {
                // TODO: implement AST
        }
}

void g_for():
{ }
{
        <t_for> <t_parenthesis_group_open> g_range() <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_range():
{ }
{
        <t_var_name> <t_membership_operator> <t_range> <t_parenthesis_group_open> g_number_value() <t_comma> g_number_value() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_try():
{ }
{
        <t_try> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> g_catch() (g_finally())?
        {
                // TODO: implement AST
        }
}

void g_catch():
{ }
{
        <t_catch> <t_parenthesis_group_open> <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> g_more_catchs()
        {
                // TODO: implement AST
        }
}

//add exception

void g_more_catchs():
{ }
{
        (g_catch())?
        {
                // TODO: implement AST
        }
}

void g_finally():
{ }
{
        <t_finally> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_not_yet():
{ }
{
        <t_not_yet>
        {
                // TODO: implement AST
        }
}

void g_do_while():
{ }
{
        <t_do> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> <t_while> <t_parenthesis_group_open> g_condition() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_input():
{ }
{
        <t_input> <t_parenthesis_group_open> g_text_value() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_output():
{ }
{
        <t_output> <t_parenthesis_group_open> g_text_value() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_switch():
{ }
{
        <t_switch> <t_parenthesis_group_open> <t_var_name> <t_parenthesis_group_close> <t_parenthesis_group_open> g_case() g_default() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_case():
{ }
{
        <t_case> <t_parenthesis_group_open> g_value() <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close> g_more_cases()
        {
                // TODO: implement AST
        }
}

void g_more_cases():
{ }
{
        (g_case())?
        {
                // TODO: implement AST
        }
}

void g_default():
{ }
{
        <t_default> <t_parenthesis_group_open> g_instruction() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_method():
{ }
{
        <t_method> <t_parenthesis_group_open> g_parameter() <t_parenthesis_group_close> <t_parenthesis_group_open> g_instruction() g_return() <t_parenthesis_group_close>
        {
                // TODO: implement AST
        }
}

void g_parameter():
{ }
{
        <t_var_name> (<t_assignment> g_value())? g_more_parameters()
        {
                // TODO: implement AST
        }
}

void g_more_parameters():
{ }
{
        (<t_comma> g_parameter())?
        {
                // TODO: implement AST
        }
}

void g_return():
{ }
{
        <t_return> g_value()
        {
                // TODO: implement AST
        }
}